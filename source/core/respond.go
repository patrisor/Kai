package core

import (
	"fmt"
	"log"
	"strings"
	"os/exec"
	"encoding/json"
	"github.com/google/generative-ai-go/genai"
)

// Method processes the JSON response generated by the AI system and takes 
// actions based on the response type. It supports handling multiple branches 
// in the execution flow.
//
// Parameters:
//  - jsonStr: The JSON string representing the AI's response.
//  - branchCounts: (Optional) The current branch count, 
// 				    defaults to 1 if not provided.
func (kai *Kai) Respond(jsonStr string, branchCounts ...int) {
	// Set branchCount to 1 by default
	branchCount := 1
	if len(branchCounts) > 0 {
		branchCount = branchCounts[0]
	}

	// TODO: Testing
	// Print the current branch count for testing
	// fmt.Printf("Processing branch: %d\n", branchCount)

	// Sanitize and unmarshal the JSON response
	responseItems, err := sanitizeAndUnmarshal(jsonStr)
	if err != nil {
		log.Printf("Error processing response: %v", err)
		return
	}
	// Iterate through the slice and process each item
	for _, item := range responseItems {
		switch item.Type {
		case "script":
			processScript(kai, item.Data)
		case "command":
			// Prune branch if a command's output has fed back into the AI
			if processCommand(kai, item.Data, branchCount) {
				return
			}
		default:
			fmt.Println("Unknown type:", item.Type)
		}
	}
	// Save the conversation history after Kai responds
	go kai.SaveHistory()
}

// Method handles the processing of a "script" response item.
//
// Parameters:
//  - kai: The AI system handling the commands.
//  - data: The JSON-encoded data representing the script to be spoken.
func processScript(kai *Kai, data json.RawMessage) {
	// Unmarshal the script data
	var scriptData struct {
		Message string `json:"message"`
		Role    string `json:"role"`
	}
	err := json.Unmarshal(data, &scriptData)
	if err != nil {
		log.Printf("Failed to parse script data: %v", err)
		return
	}

	// TODO: Print the role for context and debugging
	// fmt.Printf("Speaking (%s): %s\n", scriptData.Role, scriptData.Message)

	// Have Kai speak the script
	if err := kai.Speak(scriptData.Message); err != nil {
		log.Printf("Failed to speak: %v", err)
	}
}

// Method handles the processing of a "command" response item by executing 
// the command and determining if a new response needs to be generated based on
// the command output.
//
// Parameters:
//  - kai: The AI system handling the commands.
//  - data: The JSON-encoded data representing the command to be executed.
//  - branchCount: The current branch count to manage recursion.
func processCommand(kai *Kai, data json.RawMessage, branchCount int) bool {
	// Unmarshal the command data
	var commandData struct {
		Command string `json:"command"`
	}
	err := json.Unmarshal(data, &commandData)
	if err != nil {
		log.Printf("Failed to parse command data: %v", err)
		return false
	}

	// TODO: Testing
	// fmt.Println("Executing command:", commandData.Command)

	// Execute command
	sanitizedCommand := strings.ReplaceAll(commandData.Command, ",", "")
	output, err := kai.executeCommand(sanitizedCommand)
	if err != nil { // Error occurred
		handleCommandError(kai, err, output, branchCount)
		return true;
	}
	// No error occurred
	if output != "" { // Handle the AI response for success with output
		handleCommandSuccess(kai, output, branchCount)
		return true;
	}
	// Optionally, handle the AI response for success without output
	return false;
}

// Handle command errors and generate a new solution if needed.
//
// Parameters:
//  - kai: The AI system handling the commands.
//  - err: The error returned from the command execution.
//  - output: The output returned from the command execution.
//  - branchCount: The current branch count to manage recursion.
func handleCommandError(kai *Kai, err error, output string, branchCount int) {
	errorMessage := fmt.Sprintf(
		"Command failed: %v. " + 
		"Please analyze the error and generate a new solution.", 
		err,
	)
	// Append command output if it exists
	if output != "" {
		errorMessage += fmt.Sprintf(" Command output: %s.", output)
	}
	// Handle the AI response for errors
	kai.handleAIResponse(errorMessage, branchCount)
}

// Handle command success with output and feed the result back into the system
//
// Parameters:
//  - kai: The AI system handling the commands.
//  - output: The output returned from the successful command execution.
//  - branchCount: The current branch count to manage recursion.
func handleCommandSuccess(kai *Kai, output string, branchCount int) {
	successMessage := fmt.Sprintf(
		"Command executed successfully: %s. " +
		"Please analyze the output and provide a suitable response.",
		output,
	)
	kai.handleAIResponse(successMessage, branchCount)
}

/* ************************************************************************* */
/* ************************************************************************* */
/* ************************************************************************* */

// Method removes unwanted characters from the input JSON string to ensure it 
// is properly formatted for unmarshalling.
//
// Parameters:
//  - jsonStr: The raw JSON string to sanitize.
//
// Returns:
//  - string: The sanitized JSON string.
func sanitizeJSONString(jsonStr string) string {
	// Remove unwanted markers
	jsonStr = strings.ReplaceAll(jsonStr, "```json", "")
	jsonStr = strings.ReplaceAll(jsonStr, "```", "")
	// Trim leading and trailing spaces
	return strings.TrimSpace(jsonStr)
}

// Method sanitizes and unmarshals a JSON string into a slice 
// of ResponseItem structs.
//
// Parameters:
//  - jsonStr: The raw JSON string to be sanitized and unmarshalled.
//
// Returns:
//  - []ResponseItem: The slice of ResponseItem structs parsed from the JSON.
//  - error: Error encountered during unmarshalling, if any.
func sanitizeAndUnmarshal(jsonStr string) ([]ResponseItem, error) {

	// TODO: Testing
	// log.Printf("Raw JSON response: %s", jsonStr)

	// Sanitize the JSON string
	sanitizedJSON := sanitizeJSONString(jsonStr)
	// Ensure that opening and closing brackets match
	if strings.Count(sanitizedJSON, "[") != strings.Count(sanitizedJSON, "]") {
		return nil, fmt.Errorf("json format error: unmatched brackets")
	}
	// Unmarshal into a slice of ResponseItem
	var responseItems []ResponseItem
	err := json.Unmarshal([]byte(sanitizedJSON), &responseItems)
	if err != nil {
		return nil, fmt.Errorf("unmarshal error: %w", err)
	}
	return responseItems, nil
}

/* ************************************************************************* */
/* ************************************************************************* */
/* ************************************************************************* */

// Method sends the message back into the AI system to generate a new response 
// and recursively process the new forthcoming responses.
//
// Parameters:
//  - kai: The AI system handling the commands.
//  - message: The message to be sent back to the AI for further processing.
//  - branchCount: The current branch count to manage recursion.
func (kai *Kai) handleAIResponse(message string, branchCount int) {
	// Feed the message back into the system to generate a new response
	if newResponse, err := kai.Reason(message); err != nil {
		log.Fatalf("Failed to process new response: %v", err)
	} else {
		kai.Respond(newResponse, branchCount + 1)
	}
}

// Method executes a given shell command and returns the output.
//
// Parameters:
//  - command: The shell command to execute.
//
// Returns:
//  - string: The output from the executed command.
//  - error: Error encountered during command execution, if any.
func (kai *Kai) executeCommand(command string) (string, error) {
    cmd := exec.Command("sh", "-c", command)
    output, err := cmd.CombinedOutput()
    if err != nil {
        return "", fmt.Errorf("failed to execute command: %w", err)
    }
    return strings.TrimSpace(string(output)), nil
}


// Method appends a message to the chat history.
//
// Parameters:
//  - role: The role (e.g., "user", "system") associated with the message.
//  - content: The content of the message to append.
func (kai *Kai) appendToChatHistory(role string, content string) {
	kai.Chat.History = append(kai.Chat.History, &genai.Content{
		Parts: []genai.Part{
			genai.Text(content),
		},
		Role: role,
	})
}

/* ************************************************************************* */
/* ************************************************************************* */
/* ************************************************************************* */

// Method returns the index of the last "command" type item.
//
// Parameters:
//  - responseItems: A slice of ResponseItem representing the 
// 					 AI's structured responses.
//
// Returns:
//  - int: The index of the last "command" item. 
// 		   Returns -1 if no "command" is found.
func findLastCommandIndex(responseItems []ResponseItem) int {
	lastCommandIndex := -1
	for i, item := range responseItems {
		if item.Type == "command" {
			lastCommandIndex = i
		}
	}
	return lastCommandIndex
}